<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Ethan Chen</title>

  <!-- Open Graph / Social Media Meta Tags -->
  <meta property="og:title" content="Ethan Chen">
  <meta property="og:description" content="Personal website and interactive portfolio.">
  <meta property="og:image" content="https://echen347.github.io/profile_pic.JPG">
  <meta property="og:url" content="https://echen347.github.io/">
  <meta property="og:type" content="website">

  <!-- <link rel="stylesheet" href="./style.css"> -->
  <link rel="stylesheet" href="https://latex.vercel.app/style.css">
  <link rel="icon" href="./favicon.ico" type="image/x-icon">
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  <style>
    /* Standard Site Styles */
    header {
      margin-bottom: 2rem;
    }

    .bio-flex {
      display: flex;
      align-items: flex-start;
      gap: 1.5rem;
      margin-bottom: 1.5rem;
    }

    .bio-flex p {
      flex-grow: 1;
      margin-block-start: 0;
      margin-block-end: 0;
      order: 1;
    }

    .bio-flex img {
      width: clamp(170px, 18vw, 240px);
      border-radius: 8px;
      flex-shrink: 0;
      height: auto;
      order: 2;
    }

    @media (max-width: 700px) {
      .bio-flex {
        display: block;
      }

      .bio-flex img {
        float: right;
        max-width: 45%;
        height: auto;
        margin: 0 0 0.75rem 1rem;
      }

      .bio-flex::after {
        content: "";
        display: block;
        clear: both;
      }
    }

    footer {
      margin-top: 2rem;
    }

    /* Interactive Overlay Styles */
    #interactive-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: #000;
      z-index: 9999;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      transition: opacity 0.8s ease-in-out, visibility 0.8s;
    }

    #interactive-overlay.hidden {
      opacity: 0;
      visibility: hidden;
      pointer-events: none;
    }

    #canvas-container {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 1;
    }

    .overlay-ui {
      position: relative;
      z-index: 2;
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      pointer-events: none;
      /* Pass clicks to canvas */
    }

    .overlay-content {
      text-align: center;
      color: white;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      pointer-events: auto;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 1.5rem;
    }

    .overlay-title {
      font-size: 3.5rem;
      font-weight: 200;
      /* Light font weight */
      margin-bottom: 2rem;
      letter-spacing: 2px;
      text-shadow: 0 0 20px rgba(255, 255, 255, 0.2);
      opacity: 0;
      animation: fadeIn 2s ease forwards 0.5s;
    }

    .enter-btn {
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.3);
      color: white;
      padding: 0.8rem 2.5rem;
      font-size: 1rem;
      font-weight: 300;
      letter-spacing: 1px;
      cursor: pointer;
      transition: all 0.3s ease;
      border-radius: 50px;
      /* Pill shape */
      opacity: 0;
      animation: fadeIn 2s ease forwards 1.5s;
      font-family: inherit;
      backdrop-filter: blur(5px);
    }

    .enter-btn:hover {
      background: rgba(255, 255, 255, 0.15);
      border-color: white;
      transform: translateY(-2px);
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
    }

    /* Info Button */
    #info-btn {
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.1);
      color: rgba(255, 255, 255, 0.6);
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 0.5rem;
      font-family: inherit;
      font-size: 0.85rem;
      font-weight: 300;
      pointer-events: auto;
      transition: all 0.3s;
      opacity: 0;
      animation: fadeIn 2s ease forwards 2s;
      padding: 0.6rem 1.2rem;
      border-radius: 50px;
      backdrop-filter: blur(5px);
    }

    #info-btn:hover {
      background: rgba(255, 255, 255, 0.1);
      color: white;
      border-color: rgba(255, 255, 255, 0.3);
      transform: translateY(-1px);
    }

    #info-btn svg {
      pointer-events: none;
    }

    /* Phase Indicator */
    #phase-indicator {
      position: absolute;
      bottom: 2rem;
      left: 2rem;
      color: #aaa;
      font-family: 'Courier New', Courier, monospace;
      font-size: 0.85rem;
      pointer-events: auto;
      opacity: 0;
      animation: fadeIn 2s ease forwards 2s;
    }

    /* Modal */
    #info-modal {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.85);
      z-index: 10;
      display: flex;
      justify-content: center;
      align-items: center;
      opacity: 1;
      transition: opacity 0.3s;
      pointer-events: auto;
      backdrop-filter: blur(5px);
    }

    #info-modal.hidden {
      opacity: 0;
      pointer-events: none;
    }

    .modal-content {
      background: rgba(20, 20, 20, 0.95);
      color: #eee;
      padding: 2.5rem;
      border-radius: 12px;
      max-width: 550px;
      width: 90%;
      position: relative;
      border: 1px solid #333;
      line-height: 1.6;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      box-shadow: 0 20px 50px rgba(0, 0, 0, 0.5);
    }

    .modal-content h3 {
      margin-top: 0;
      font-weight: 400;
      color: #64b5f6;
      margin-bottom: 1rem;
    }

    #close-modal {
      position: absolute;
      top: 1rem;
      right: 1rem;
      font-size: 1.5rem;
      cursor: pointer;
      color: #777;
      transition: color 0.2s;
    }

    #close-modal:hover {
      color: white;
    }

    @keyframes fadeIn {
      to {
        opacity: 1;
      }
    }

    #show-interactive-btn {
      background: none;
      border: none;
      cursor: pointer;
      color: #bbb;
      /* Subtle gray */
      padding: 0.4rem;
      margin-left: 0.5rem;
      vertical-align: middle;
      transition: all 0.3s ease;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      border-radius: 50%;
    }

    #show-interactive-btn:hover {
      color: #333;
      /* Darker on hover */
      background: rgba(0, 0, 0, 0.05);
      transform: rotate(-180deg);
    }
  </style>
</head>

<body>
  <!-- Interactive Overlay -->
  <div id="interactive-overlay">
    <canvas id="canvas-container"></canvas>

    <div class="overlay-ui">
      <div class="overlay-content">
        <h1 class="overlay-title">Ethan Chen</h1>
        <button class="enter-btn" id="enter-site-btn">Enter Profile</button>

        <button id="info-btn" title="What am I looking at?">
          <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
            <circle cx="12" cy="12" r="10"></circle>
            <line x1="12" y1="16" x2="12" y2="12"></line>
            <line x1="12" y1="8" x2="12.01" y2="8"></line>
          </svg>
          <span class="info-text">What is this?</span>
        </button>
      </div>

      <div id="phase-indicator">Phase: MCMC</div>
    </div>

    <!-- Info Modal -->
    <div id="info-modal" class="hidden">
      <div class="modal-content">
        <span id="close-modal">&times;</span>
        <h3>Sequential Monte Carlo Visualization</h3>
        <p>
          This simulation visualizes a <a href="https://en.wikipedia.org/wiki/Particle_filter"
            target="_blank"><strong>Sequential Monte Carlo</strong></a> algorithm tracking a moving multimodal
          distribution.
        </p>
        <ul
          style="text-align: left; margin-top: 1rem; padding-left: 1.2rem; gap: 0.5rem; display: flex; flex-direction: column;">
          <li><strong>MCMC Step</strong>: Particles evolve via Langevin dynamics, utilizing the score and Gaussian noise
            to explore the high-probability modes of the target distribution.</li>
          <li><strong>Resampling Step</strong>: A probability-weighted resampling scheme filters the particle
            approximation. Low-weight particles are killed, while high-weight particles are replicated, focusing
            computational effort on the relevant regions of the state space.</li>
          <li><strong>Targets</strong>: Represent the unnormalized modes of the hidden distribution. <em>Click to add a
              new mode.</em></li>
        </ul>
      </div>
    </div>
  </div>

  <header>
    <center>
      <h1>Ethan Chen <button id="show-interactive-btn" title="Return to Interactive Mode"><svg
            xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none"
            stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8" />
            <path d="M3 3v5h5" />
          </svg></button></h1>
      <nav>
        <a href="/">Home</a> /
        <a href="writing.html">Writing</a> /
        <a href="photography.html">Photography</a>
      </nav>
    </center>
  </header>
  <main>
    <div class="bio-flex">
      <img src="headshot-cur-cruise.JPG" alt="Ethan Chen headshot">
      <p>
        Hi! I'm a third-year undergraduate at the Georgia Institute of Technology studying Mathematics. I am fortunate
        to work with Prof. <a href="https://yongxin.ae.gatech.edu/" target="_blank">Yongxin Chen</a> and Prof. <a
          href="https://amirmohan.github.io/" target="_blank">Amirali Aghazadeh</a> on the mathematical foundations of
        machine learning. Outside of research, I enjoy <a href="photography.html" target="_blank">photography</a>, <a
          href="writing.html" target="_blank">writing</a>, <a href="https://goodreads.com/chenthan"
          target="_blank">reading</a>, and bouldering. This past summer I participated in a REU at Williams College;
        next summer I'll be a Quantitative Trading Intern at Susquehanna International Group (SIG).
      </p>
    </div>

    <section>
      <h2>Research</h2>
      <p>
        My research centers on reasoning about machine learning from mathematical first principles, with a particular
        focus on high-dimensional probability and geometric deep learning. Previously, I have worked on
        structure-preserving generative models, including diffusion on Riemannian manifolds,
        normalizing flows, and sampling acceleration for discrete processes.
      </p>
      <p>
        Currently, I am working on convergence bounds for Sequential Monte Carlo. Recently, I also worked on Geometric
        Flow Matching and Martingale Optimal Transport.
      </p>
      <p>
        I am also interested in differential geometry, natural language processing, and algorithmic alignment.
      </p>
    </section>

    <section>
      <h2>Academics</h2>
      <p>
        I have taken a fair amount of undergraduate and graduate courses in mathematics and computer science. Here are
        some highlights, with * indicating graduate courses.
      </p>

      <h4>Highlighted Mathematics Coursework</h4>
      <ul>
        <li>*MATH 8803 RIE: Optimal Transport: Theory and Applications (Fall 2025)</li>
        <li>*MATH 6221: Probability Theory for Engineers (Fall 2025)</li>
        <li>*MATH 7339: Advanced Analysis (Spring 2025)</li>
        <li>*MATH 6455: Differential Geometry I (Spring 2025)</li>
        <li>*MATH 6579: Measure Theory for Engineers (Fall 2024)</li>
        <li>*MATH 6121: Algebra I (Fall 2024)</li>
        <li>*MATH 8803 GHO: Geometric Inequalities (Fall 2024)</li>
        <li>MATH 3236: Statistical Theory (Spring 2025)</li>
        <li>MATH 4782: Quantum Information & Computation (Fall 2024)</li>
        <li>MATH 4441: Differential Geometry (Fall 2024)</li>
        <li>MATH 4150: Intro To Number Theory (Spring 2024)</li>
        <li>MATH 3235: Probability Theory (Spring 2024)</li>
        <li>MATH 4022: Intro To Graph Theory (Fall 2023)</li>
        <li>MATH 3406: Second Course in Linear Algebra (Fall 2023) <a href="notes/MATH 3406 notes.pdf"
            target="_blank"><b>notes</b></a></li>
        </li>
      </ul>

      <h4>Highlighted Computer Science & ECE Coursework</h4>
      <ul>
        <li>*ECE 8803 HOS: High-Dimensional Statistical Signal Processing and Optimization (Fall 2025)</li>
        <li>*ECE 8803 GDL: Generative and Geometric Deep Learning (Fall 2025)</li>
        <li>*CS 8803 DTA: Dynamics to Algorithms: Optimization, Sampling, and Games (Fall 2025)</li>
        <li>*ECE 7751: Graphical Models in Machine Learning (Spring 2025)</li>
        <li>*ECE 6270: Convex Optimization (Spring 2025)</li>
        <li>*ECE 6254: Statistical Machine Learning (Spring 2025)</li>
        <li>CS 4650: Natural Language Processing (Fall 2024)</li>
        <li>CS 3511: Design and Analysis of Algorithms - Honors (Spring 2024)</li>
      </ul>
    </section>

    <section>
      <h2>Contact</h2>
      <p>ec [at] gatech [dot] edu /
        <a href="https://www.linkedin.com/in/ethanc27/" target="_blank">linkedin</a>
      </p>
    </section>
  </main>
  <footer>
    <p>&copy; 2026 Ethan Chen. All rights reserved. Last updated: 1/1/2026</p>
    <p>Powered by <a href="https://latex.vercel.app/" target="_blank">LaTeX.css</a></p>
  </footer>

  <script>
    // --- Interactive Overlay Logic ---
    const overlay = document.getElementById('interactive-overlay');
    const enterBtn = document.getElementById('enter-site-btn');
    const showInteractiveBtn = document.getElementById('show-interactive-btn');
    const infoBtn = document.getElementById('info-btn');
    const infoModal = document.getElementById('info-modal');
    const closeModal = document.getElementById('close-modal');
    const phaseIndicator = document.getElementById('phase-indicator');
    const canvas = document.getElementById('canvas-container');
    const ctx = canvas.getContext('2d');

    let animationId;
    let particles = [];
    let targets = [];
    let isActive = true;
    let scale = 1;
    let lastSpawnTime = 0; // For throttling clicks

    // Check if user has already visited
    try {
      if (sessionStorage.getItem('introShown')) {
        isActive = false;
        overlay.classList.add('hidden');
      }
    } catch (e) {
      console.warn('SessionStorage not available:', e);
    }

    // Simulation State
    let frameCount = 0;
    const MCMC_DURATION = 180; // Frames (approx 3s)
    const RESAMPLE_DURATION = 45; // Frames (approx 0.75s) - Slightly longer
    let currentPhase = 'MCMC'; // 'MCMC' or 'RESAMPLE'

    // Resize
    function resize() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;

      // Non-linear scaling for mobile: 
      // Boosts scale on small screens so elements don't vanish
      const ratio = Math.min(canvas.width, canvas.height) / 800;
      scale = Math.max(0.6, Math.pow(ratio, 0.7));

      if (isActive && canvas.width > 0 && canvas.height > 0) {
        initTargets();
        initParticles();
      }
    }
    window.addEventListener('resize', resize);


    // --- SMC Simulation Classes ---

    class Target {
      constructor(x, y) {
        this.x = x || Math.random() * canvas.width;
        this.y = y || Math.random() * canvas.height;
        // Constant speed, random direction
        this.speed = 0.3 * scale;
        this.angle = Math.random() * Math.PI * 2;
        this.vx = Math.cos(this.angle) * this.speed;
        this.vy = Math.sin(this.angle) * this.speed;
        this.radius = (Math.random() * 40 + 50) * scale;
        this.phase = Math.random() * Math.PI * 2;
      }

      update() {
        // Perturb angle slightly
        this.angle += (Math.random() - 0.5) * 0.1; // Small random perturbation

        // Bounce off walls and adjust angle
        if (this.x < 0) {
          this.x = 0;
          this.angle = Math.PI - this.angle; // Reflect horizontally
        } else if (this.x > canvas.width) {
          this.x = canvas.width;
          this.angle = Math.PI - this.angle; // Reflect horizontally
        }

        if (this.y < 0) {
          this.y = 0;
          this.angle = -this.angle; // Reflect vertically
        } else if (this.y > canvas.height) {
          this.y = canvas.height;
          this.angle = -this.angle; // Reflect vertically
        }

        // Ensure angle is within [0, 2PI)
        this.angle = (this.angle + 2 * Math.PI) % (2 * Math.PI);

        this.vx = Math.cos(this.angle) * this.speed;
        this.vy = Math.sin(this.angle) * this.speed;

        this.x += this.vx;
        this.y += this.vy;
        this.phase += 0.05;
      }

      draw() {
        const pulse = Math.sin(this.phase) * 0.2 + 0.8;
        const gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.radius * pulse);
        gradient.addColorStop(0, 'rgba(64, 224, 208, 0.15)');
        gradient.addColorStop(1, 'rgba(64, 224, 208, 0)');

        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius * pulse, 0, Math.PI * 2);
        ctx.fill();

        ctx.fillStyle = 'rgba(64, 224, 208, 0.3)';
        ctx.beginPath();
        ctx.arc(this.x, this.y, 2, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    class Particle {
      constructor(x, y) {
        this.x = x || Math.random() * canvas.width;
        this.y = y || Math.random() * canvas.height;
        this.vx = (Math.random() - 0.5) * 1;
        this.vy = (Math.random() - 0.5) * 1;
        this.weight = 0;
        this.state = 'ALIVE'; // ALIVE, DYING, SPAWNING
        this.scale = 1;
        this.opacity = 1;
        this.childrenToSpawn = 0; // For visual resampling
        this.nearestTargetIndex = -1; // For density control
      }

      updateMCMC() {
        if (this.state === 'DYING') return; // Dead particles don't move

        // Langevin Dynamics: Drift + Diffusion
        // 1. Drift (Gradient of log-density): Move towards high probability areas
        let nearestTarget = null;
        let minDist = Infinity;
        this.nearestTargetIndex = -1;

        // Find nearest target (approximate gradient)
        targets.forEach((t, index) => {
          const dx = t.x - this.x;
          const dy = t.y - this.y;
          const d2 = dx * dx + dy * dy;
          if (d2 < minDist) {
            minDist = d2;
            nearestTarget = t;
            this.nearestTargetIndex = index;
          }
        });

        if (nearestTarget) {
          const dx = nearestTarget.x - this.x;
          const dy = nearestTarget.y - this.y;
          // Drift force proportional to distance (harmonic potential)
          // Small drift to guide them, but not dominate
          this.vx += dx * 0.001;
          this.vy += dy * 0.001;
        }

        // 2. Diffusion (Random Walk) - Stronger noise for "diffusion" look
        this.vx += (Math.random() - 0.5) * 2.0;
        this.vy += (Math.random() - 0.5) * 2.0;

        // Apply Velocity
        this.x += this.vx;
        this.y += this.vy;

        // Damping (Friction) - Less damping to allow jiggle
        this.vx *= 0.80;
        this.vy *= 0.80;

        // Calculate Weight (Likelihood)
        let maxWeight = 0;
        for (let t of targets) {
          const dx = this.x - t.x;
          const dy = this.y - t.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          // Larger sigma so particles "visually far" (but in light) survive
          const sigma = 60 * scale;
          const w = Math.exp(-(dist * dist) / (2 * sigma * sigma));
          if (w > maxWeight) maxWeight = w;
        }
        this.weight = maxWeight;
      }

      updateVisuals() {
        // Handle animations
        if (this.state === 'DYING') {
          this.scale *= 0.9; // Slower shrink
          this.opacity -= 0.05; // Faster fade (since duration is shorter)
        } else if (this.state === 'SPAWNING') {
          this.scale += (1 - this.scale) * 0.2;
          this.opacity += 0.1;
          if (this.opacity > 1) {
            this.opacity = 1;
            this.state = 'ALIVE'; // Once fully spawned, it's alive
          }
        }
      }

      draw() {
        if (this.opacity <= 0) return;

        if (this.state === 'DYING') {
          // Red death
          ctx.fillStyle = `rgba(255, 50, 50, ${this.opacity})`;
        } else {
          // Normal Blue -> Cyan
          const alpha = (0.2 + this.weight * 0.8) * this.opacity;
          ctx.fillStyle = `rgba(${200 - this.weight * 100}, ${220 + this.weight * 35}, 255, ${alpha})`;
        }

        ctx.beginPath();
        ctx.arc(this.x, this.y, 1.5 * this.scale, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    // Click to add target
    canvas.addEventListener('mousedown', (e) => {
      if (!isActive) return;

      // Throttle clicks (max 5 per second)
      const now = Date.now();
      if (now - lastSpawnTime < 200) return;
      lastSpawnTime = now;

      const t = new Target(e.clientX, e.clientY);
      targets.push(t);

      // Spawn cloud of particles around new target
      // Cap immediate spawn if way too many
      if (particles.length < 1200) {
        for (let i = 0; i < 20; i++) {
          const angle = Math.random() * Math.PI * 2;
          const r = Math.random() * 100 * scale; // Match new visual radius roughly
          const px = t.x + Math.cos(angle) * r;
          const py = t.y + Math.sin(angle) * r;

          const p = new Particle(px, py);
          p.state = 'SPAWNING';
          p.opacity = 0;
          particles.push(p);
        }
      }
    });

    function initTargets() {
      targets = [];
      // Create 5 initial targets
      for (let i = 0; i < 5; i++) targets.push(new Target());
    }

    function initParticles() {
      particles = [];
      const count = Math.min(window.innerWidth * 0.8, 1200);
      for (let i = 0; i < count; i++) {
        particles.push(new Particle());
      }
    }

    function performResampling() {
      // Systematic Resampling
      const N = particles.length;
      if (N === 0) {
        initParticles(); // Reinitialize if all particles are gone
        return;
      }

      // 1. Calculate total weight and normalize
      let totalWeight = 0;
      particles.forEach(p => {
        // Ensure weights are positive for normalization
        if (p.weight < 0.0001) p.weight = 0.0001;
        totalWeight += p.weight;
      });

      // Calculate normalized weights
      particles.forEach(p => p.normWeight = p.weight / totalWeight);

      // 2. Calculate counts using Systematic Resampling
      // Cap the number of survivors/clones to maintain performance
      const MAX_PARTICLES = 1000;
      const targetCount = Math.min(N, MAX_PARTICLES); // Downsample if too many

      // Density Control: Cap per mode
      const MAX_PER_TARGET = 350; // Max particles per mode
      const targetCounts = new Array(targets.length).fill(0);

      const step = 1 / targetCount;
      let start = Math.random() * step; // Random start for the first pointer
      let cumulativeWeight = 0;
      let particleIndex = 0;

      // Reset childrenToSpawn for all particles
      particles.forEach(p => p.childrenToSpawn = 0);

      for (let i = 0; i < targetCount; i++) {
        const threshold = start + i * step;
        // Move through the cumulative distribution until we find the parent
        while (cumulativeWeight + particles[particleIndex].normWeight < threshold) {
          cumulativeWeight += particles[particleIndex].normWeight;
          particleIndex++;
          // Handle edge case where particleIndex might exceed array bounds
          if (particleIndex >= N) {
            particleIndex = N - 1; // Should not happen with correct normalization and step
            break;
          }
        }

        // Density Check: If this particle belongs to a full mode, skip spawning
        const tIdx = particles[particleIndex].nearestTargetIndex;
        if (tIdx !== -1) {
          if (targetCounts[tIdx] >= MAX_PER_TARGET) {
            continue; // Skip this spawn
          }
          targetCounts[tIdx]++;
        }

        particles[particleIndex].childrenToSpawn++;
      }

      // 3. Apply Visual Strategy
      const newParticles = [];

      // First, process existing particles based on their childrenToSpawn count
      particles.forEach(p => {
        if (p.childrenToSpawn === 0) {
          // This particle is a loser, mark it for dying animation
          p.state = 'DYING';
          newParticles.push(p); // Keep it in the array to animate its death
        } else {
          // This particle is a winner, keep the original as ALIVE
          p.state = 'ALIVE';
          newParticles.push(p);

          // Spawn (childrenToSpawn - 1) clones
          for (let k = 1; k < p.childrenToSpawn; k++) {
            const clone = new Particle(p.x, p.y);
            clone.state = 'SPAWNING';
            clone.scale = 0.1; // Start small
            clone.opacity = 0; // Start transparent
            // Add some noise to velocity for visual diversity
            clone.vx = (Math.random() - 0.5) * 2;
            clone.vy = (Math.random() - 0.5) * 2;
            newParticles.push(clone);
          }
        }
      });

      // Update the main particles array
      particles = newParticles;
    }

    function animate() {
      if (!isActive) return;

      // Safety check: If active but no particles (e.g. failed init), try to init
      if (particles.length === 0 && canvas.width > 0) {
        initTargets();
        initParticles();
      }

      frameCount++;
      const cycle = frameCount % (MCMC_DURATION + RESAMPLE_DURATION);

      // Phase Logic
      if (cycle < MCMC_DURATION) {
        if (currentPhase !== 'MCMC') {
          currentPhase = 'MCMC';
          phaseIndicator.textContent = "Phase: MCMC";
          phaseIndicator.style.color = "#aaa";
          // Cleanup dead particles
          particles = particles.filter(p => p.state !== 'DYING' || p.opacity > 0);
        }

        // MCMC Step
        particles.forEach(p => p.updateMCMC());

      } else {
        if (currentPhase !== 'RESAMPLING') {
          currentPhase = 'RESAMPLING';
          phaseIndicator.textContent = "Phase: RESAMPLING";
          phaseIndicator.style.color = "#64b5f6";
          performResampling();
        }
        // During resampling, particles mostly just animate their death/birth
        // Maybe slight movement
        particles.forEach(p => p.updateVisuals());
      }

      // Background
      const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
      gradient.addColorStop(0, 'rgba(10, 15, 30, 0.4)'); // Higher opacity to remove tails
      gradient.addColorStop(1, 'rgba(5, 5, 10, 0.4)');
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      targets.forEach(t => {
        t.update();
        t.draw();
      });

      particles.forEach(p => {
        p.draw();
      });

      animationId = requestAnimationFrame(animate);
    }

    // Start
    window.addEventListener('load', () => {
      resize();
      animate();
    });

    // Interactions
    enterBtn.addEventListener('click', () => {
      isActive = false;
      overlay.classList.add('hidden');
      try {
        sessionStorage.setItem('introShown', 'true');
      } catch (e) {
        console.warn('SessionStorage failed:', e);
      }
      cancelAnimationFrame(animationId);
    });

    showInteractiveBtn.addEventListener('click', () => {
      isActive = true;
      overlay.classList.remove('hidden');
      // Force re-initialization
      initTargets();
      initParticles();
      // Restart loop if needed
      cancelAnimationFrame(animationId);
      animate();
    });

    // Info Modal
    infoBtn.addEventListener('click', () => {
      infoModal.classList.remove('hidden');
    });

    closeModal.addEventListener('click', () => {
      infoModal.classList.add('hidden');
    });

    infoModal.addEventListener('click', (e) => {
      if (e.target === infoModal) {
        infoModal.classList.add('hidden');
      }
    });

  </script>
</body>

</html>